# lesson28

### Попов Георгий Андреевич

![image](https://github.com/user-attachments/assets/f7b2e7e9-3b15-43af-b630-679eca02e108)

### типо шутка про chatGPT

### вопросы:

### 1. 
Чтобы сложить два положительных 8-битных числа, например 5 (00000101) и 3 (00000011), выполним побитное сложение:

00000101
+ 00000011
 ____
 00001000  (8 в десятичной системе)


Если же числа отрицательные и записаны в дополнительном коде, процесс изменения может потребовать преобразования чисел в дополнительный код перед сложением. Например, для -5, дополнительный код будет выглядеть так:

00000101 → 11111011 (дополнительный код для -5)


### 2.
Дополнительный код — это способ представления отрицательных чисел. Чтобы получить дополнительный код для числа, нужно:
1. Записать число в прямом коде (обычный двоичный вид).
2. Инвертировать все биты (заменить 0 на 1 и 1 на 0).
3. Добавить 1 к полученному числу.

### 3. 
Переполнение может возникнуть в двух случаях:
- Когда оба слагаемых положительны и результат становится отрицательным.
- Когда оба слагаемых отрицательны и результат становится положительным.

### 4. 
Сложение выполняет арифметико-логическое устройство (АЛУ). Это устройство может выполнять ряд арифметических и логических операций, включая сложение, вычитание, умножение и деление.

### 5. 
Вычитание можно выполнить с помощью сложения, используя дополнительный код. Это позволяет не разрабатывать отдельное аппаратное устройство, а использовать уже имеющееся для сложения.

### 6. 
Чтобы перемножить, например, 3 (0011) и 2 (0010) в двоичной системе:

0011
x  0010
____
0000  (3*0)
0011   (3*1 сдвинут на 1 позицию)
____
0110   (6 в десятичной системе)


При изменении знака у одного из сомножителей алгоритм остается тем же, но результат будет отрицательным.

### 7. 
Числа со знаком могут представлять как положительные, так и отрицательные значения, что требует учета знака. Беззнаковые числа всегда положительны или нулевые, поэтому их сравнение проще.

### 8.
Поразрядные операции — это операции, которые выполняются над отдельными битами числа. Примеры: битовые И (AND), ИЛИ (OR), исключающее ИЛИ (XOR), побитовый сдвиг.

### 9. 
Арифметические операции, такие как сложение и вычитание, выполняются на уровне значений (например, 4 + 5 = 9), а не индивидуально на каждом бите, что и делает их не поразрядными.

### 10.
Маска — это двоичное число, используемое для выполнения побитовых операций. Она помогает выделить или изменить определенные биты исходного числа.

### 11.
Чтобы сбросить определенный бит, можно использовать маску с нулями на месте сбрасываемого бита и единицами на всех других. Например, чтобы сбросить третий бит:

Маска: 11110111 (глядя справа)
Число: 01010101
Результат: 01010001 (побитовое И с маской)


### 12. 
Чтобы сбросить два младших бита в 16-разрядном числе, используйте маску 1111111111111100 (то есть 0xFFFC) и операцию AND.

### 13. 
Чтобы установить определенный бит, создайте маску с единицей на месте устанавливаемого бита и нулями на остальных местах, используя побитовое ИЛИ:

Маска: 00000001 (установить младший бит)


### 14. 
Следующая маска для установки двух старших битов: 1100000000000000 (то есть 0xC000). Используйте операцию OR.

### 15. 
Чтобы определить делимость на 4, нужно проверить последние 2 бита числа (они должны быть равны 00). Для 87 аналогично проверяется делимость, но для этого нужно разделить 87 на 1 (т.е. 10001011). В общем случае для числа N, если (N & 3) == 0, то число делится на 4.

### 16. 
Установка/сброс битов может использоваться, например, для управления флагами в программировании, настройки битовых полей структуры и управления состояниями устройств.

### 17. 
Операция XOR возвращает 1, если биты различны, и 0, если они равны. Она полезна для проверки различий между двумя числами или для инверсии определенных битов.

### 18. 
Можно создать простой алгоритм шифрования, используя изменение маски. Например, можно использовать итерацию для генерации маски на основе пользовательского пароля:

1. Закодируйте текст в двоичном формате.
2. Сгенерируйте маску, например, возьмите ASCII-коды символов пароля и меняйте их в зависимости от индекса символа исходного сообщения, добавляя и умножая по порядку.
3. Примените операцию XOR между закодированными данными и маской.

Таким образом, при каждом новом символе получается новая маска, что усложняет расшифровку.

### 19. 
Для определения, совпадают ли биты S и S', можно использовать операцию XOR. Если S и S' равны, результат будет равен 0. Это можно записать как: S ^ S' == 0.

### 20.
Операция «НЕ» (инверсия) является важной при получении отрицательных чисел в дополнительном коде, поскольку для создания отрицательного числа необходимо инвертировать все биты и затем добавить 1.

### 21.
Чтобы выполнить инверсию всех битов без использования операции «НЕ», можно использовать XOR с маской, где все биты равны 1. Например, для 8-битного числа:

Маска: 11111111
Число: 01010101
Результат: 01010101 ^ 11111111 = 10101010


### 22. 
Сдвиг — это операция, при которой биты числа сдвигаются влево или вправо. Виды сдвига:
- Логический сдвиг: Биты сдвигаются, заполняя пустые позиции нулями.
- Арифметический сдвиг: Сдвиг выполняется с сохранением знака (при арифметическом сдвиге вправо старший бит (знак) копируется).
- Циклический сдвиг: Биты, выходящие за пределы разряда, возвращаются в начало.

### 23.
- Логический сдвиг влево: Младшие биты сбрасываются, и старшие биты заполняются нулями.
- Логический сдвиг вправо: Младшие биты сбрасываются, старшие заполняются нулями.
- Арифметический сдвиг вправо: Младшие биты сбрасываются, старший бит сохраняется.

### 24.
- Сдвиг влево:
    00000011 (3) → 00000110 (6) (удваивается)
  

- Сдвиг вправо:
    00000110 (6) → 00000011 (3) (уменьшается вдвое)
  

### 25. 
Логический сдвиг не подходит для отрицательных чисел, так как он не сохраняет знак (для отрицательных чисел, представленных в дополнительном коде, старший бит должен оставаться 1). Арифметический сдвиг вправо сохраняет данный бит и корректно сокращает число вдвое.

### 26.
Арифметический сдвиг влево не требуется, так как он по своей сути аналогичен логическому сдвигу влево: обе операции удваивают число.

### 27.
При арифметическом сдвиге отрицательного нечётного числа вправо:
- Если число нечётное, результат будет равен (N / 2) округленно в сторону меньшего целого.
- Для положительных нечётных чисел аналогично.
- Для четных чисел: результат будет точно делиться на 2.

 ### 28. Применения сдвигов
 Сдвиги могут применяться в различных задачах, таких как:
- Оптимизация вычислений (умножение или деление на 2).
- Кодирование данных (например, сжатие).
- Обработка битовых данных, например, в графических приложениях или сетевых протоколах.
- В криптографии для перемешивания и шифрования данных.

### Задачи

1. Переведем числа 31 и 19 в двоичный код:
      31 = 00011111
   19 = 00010011
   
   Сложение:
          00011111
     + 00010011
     ____
    00110010 (Код: 1B, Десятичное значение: 50)
   

2. Переводим -31 в дополнительном коде:
      31 = 00011111
   -31 = 11100001 (инвертируем и добавляем 1)
   
   Сложение:
          11100001
     + 00010011
     ____
   11110000 (Получаем -12 в десятичном виде, т. е. -31 + 19 = -12)
   
   В 16-разрядном коде это будет аналогично, просто значения будут занимать больше разрядов.

3. Проверим тождество с произвольными числами A и B, например A = 23 (00010111), B = 15 (00001111):
      A - B = A + (-B)
   00010111
 - 00001111
 ____
   00001000 (8)

   -B:
   00001111 → 11110001 → 11110010 
   
   Сложение:
      00010111
 + 11110001
 _____
   00001000
 









